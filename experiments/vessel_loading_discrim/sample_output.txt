#------------------------------------------------------------------------------
# irace: An implementation in R of (Elitist) Iterated Racing
# Version: 3.4.1.9fcaeaf
# Copyright (C) 2010-2020
# Manuel Lopez-Ibanez     <manuel.lopez-ibanez@manchester.ac.uk>
# Jeremie Dubois-Lacoste  
# Leslie Perez Caceres    <leslie.perez.caceres@ulb.ac.be>
#
# This is free software, and you are welcome to redistribute it under certain
# conditions.  See the GNU General Public License for details. There is NO
# WARRANTY; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
#
# irace builds upon previous code from the race package:
#     race: Racing methods for the selection of the best
#     Copyright (C) 2003 Mauro Birattari
#------------------------------------------------------------------------------
# installed at: /AutoIG/bin/irace
# called with: --seed 42 --scenario /AutoIG/scripts/scenario.R --parameter-file params.irace --train-instances-file instances --exec-dir ./ --max-experiments 180 --target-runner /AutoIG/scripts/target-runner --debug-level 2
## irace scenario:
scenarioFile = "./scenario.txt"
parameterFile = "/AutoIG/experiments/vessel_loading_discrim/params.irace"
execDir = "/AutoIG/experiments/vessel_loading_discrim"
logFile = "/AutoIG/experiments/vessel_loading_discrim/irace.Rdata"
recoveryFile = NULL
instances = "dummy"
initConfigurations = NULL
trainInstancesDir = ""
trainInstancesFile = "/AutoIG/experiments/vessel_loading_discrim/instances"
configurationsFile = ""
forbiddenExps = NULL = expression()
forbiddenFile = ""
targetRunner = "/AutoIG/scripts/target-runner"
targetRunnerRetries = 0
targetRunnerData = ""
targetRunnerParallel = NULL
targetEvaluator = NULL
maxExperiments = 180
maxTime = 0
budgetEstimation = 0.02
digits = 4
debugLevel = 2
nbIterations = 0
nbExperimentsPerIteration = 0
sampleInstances = TRUE
testType = "friedman"
firstTest = 5
eachTest = 1
minNbSurvival = 0
nbConfigurations = 0
mu = 5
confidence = 0.95
deterministic = FALSE
seed = 42
parallel = 0
loadBalancing = TRUE
mpi = FALSE
batchmode = "0"
softRestart = TRUE
softRestartThreshold = 1e-04
testInstancesDir = ""
testInstancesFile = ""
testInstances = NULL
testNbElites = 1
testIterationElites = FALSE
elitist = TRUE
elitistNewInstances = 1
elitistLimit = 2
repairConfiguration = function (id, allConfigurations, parameters, digits, nConfsPreviousRaces = 0) {    outputDir <- "./detailed-output/"    configuration <- allConfigurations[id - nConfsPreviousRaces,         ]    repairModel <- paste(outputDir, "/repair.eprime", sep = "")    if (!file.exists(repairModel)) {        return(configuration)    }    start_time <- Sys.time()    originalConfiguration <- configuration    baseFileName <- id    outFile <- paste(outputDir, "/repairout-", baseFileName,         sep = "")    if (file.exists(outFile)) {        configuration <- read.csv(outFile)        return(configuration)    }    lsParams <- sort(parameters$names)    for (param in lsParams) {        maxParam <- NA        if (endsWith(param, "_min")) {            maxParam <- paste(substr(param, 1, nchar(param) -                 3), "max", sep = "")        }        else if (endsWith(param, "Min")) {            maxParam <- paste(substr(param, 1, nchar(param) -                 3), "Max", sep = "")        }        if (!is.na(maxParam)) {            minVal <- min(configuration[[param]], configuration[[maxParam]])            maxVal <- max(configuration[[param]], configuration[[maxParam]])            configuration[[param]] <- minVal            configuration[[maxParam]] <- maxVal        }    }    paramFile <- paste(outputDir, "/repair-", baseFileName, ".param",         sep = "")    lsLines <- c()    for (paramName in colnames(configuration)) {        if (!(paramName %in% c(".ID.", ".PARENT."))) {            val <- configuration[[paramName]]            lsLines <- c(lsLines, paste("letting", paramName,                 "be", val))        }    }    writeLines(lsLines, con <- file(paramFile))    close(con)    seed <- as.integer(id)    cmd <- paste("conjure solve repair.essence ", paramFile,         " -o ", outputDir, " --use-existing-model repair.eprime ",         " --solver-options \"-timelimit 120 -varorder domoverwdeg -randomiseorder",         "-randomseed", seed, "\"", " --copy-solutions=off")    cat(cmd, "\n")    exitCode <- system(cmd, intern = FALSE, wait = TRUE)    if (exitCode != 0) {        cat("ERROR while repairing configuration \n")        print(configuration)        return(NULL)    }    solutionFile <- paste(outputDir, "/repair-repair-", baseFileName,         "-solution000001.solution", sep = "")    lsLines <- readLines(con <- file(solutionFile))    close(con)    lsLines <- gsub("repaired_", "", lsLines)    lsLines <- lsLines[grep("letting ", lsLines)]    baseTempName <- paste(outputDir, "/repair-repair-", baseFileName,         sep = "")    for (endName in c(".eprime-info", ".eprime-infor", ".eprime-minion",         ".eprime-param", "-solution000001.eprime-solution", "-solution000001.solution")) {        file.remove(paste(baseTempName, endName, sep = ""))    }    file.remove(paramFile)    for (paramName in colnames(configuration)) {        if (!(paramName %in% c(".ID.", ".PARENT."))) {            pattern <- paste("letting ", paramName, " be ", sep = "")            s <- lsLines[grep(pattern, lsLines)]            newVal <- as.integer(trimws(strsplit(s, " be ")[[1]][2]))            configuration[[paramName]] <- newVal        }    }    cat("\nBefore repair: \n")    print(originalConfiguration)    cat("After repair: \n")    print(configuration)    cat("\n")    end_time <- Sys.time()    cat("\nRepairing time: ", round(end_time - start_time, 2),         " seconds\n")    write.csv(configuration, file = outFile, row.names = FALSE)    return(configuration)}
capping = FALSE
cappingType = "median"
boundType = "candidate"
boundMax = NULL
boundDigits = 0
boundPar = 1
boundAsTimeout = TRUE
postselection = 0
aclib = FALSE
## end of irace scenario
# --- Parameters Hierarchy ---
[1] "deck_width_tuned"   "deck_length_tuned"  "n_containers_delta" "n_classes_tuned"    "coverage_max"      
  deck_width_tuned  deck_length_tuned n_containers_delta    n_classes_tuned       coverage_max 
                 1                  1                  1                  1                  1 
  deck_width_tuned  deck_length_tuned n_containers_delta    n_classes_tuned       coverage_max 
                ""                 ""                 ""                 ""                 "" 
           Parameter Level Depends.on
1   deck_width_tuned     1           
2  deck_length_tuned     1           
3 n_containers_delta     1           
4    n_classes_tuned     1           
5       coverage_max     1           

# ------------------------
$names
[1] "deck_width_tuned"   "deck_length_tuned"  "n_containers_delta" "n_classes_tuned"    "coverage_max"      

$types
  deck_width_tuned  deck_length_tuned n_containers_delta    n_classes_tuned       coverage_max 
               "i"                "i"                "i"                "i"                "i" 

$switches
      deck_width_tuned      deck_length_tuned     n_containers_delta        n_classes_tuned           coverage_max 
  "-deck_width_tuned "  "-deck_length_tuned " "-n_containers_delta "    "-n_classes_tuned "       "-coverage_max " 

$domain
$domain$deck_width_tuned
[1]   1 100

$domain$deck_length_tuned
[1]   1 100

$domain$n_containers_delta
[1]  1 20

$domain$n_classes_tuned
[1]  1 10

$domain$coverage_max
[1]  10 100


$conditions
$conditions$deck_width_tuned
[1] TRUE

$conditions$deck_length_tuned
[1] TRUE

$conditions$n_containers_delta
[1] TRUE

$conditions$n_classes_tuned
[1] TRUE

$conditions$coverage_max
[1] TRUE


$isFixed
  deck_width_tuned  deck_length_tuned n_containers_delta    n_classes_tuned       coverage_max 
             FALSE              FALSE              FALSE              FALSE              FALSE 

$transform
$transform$deck_width_tuned
[1] ""

$transform$deck_length_tuned
[1] ""

$transform$n_containers_delta
[1] ""

$transform$n_classes_tuned
[1] ""

$transform$coverage_max
[1] ""


$depends
$depends$deck_width_tuned
character(0)

$depends$deck_length_tuned
character(0)

$depends$n_containers_delta
character(0)

$depends$n_classes_tuned
character(0)

$depends$coverage_max
character(0)


$hierarchy
  deck_width_tuned  deck_length_tuned n_containers_delta    n_classes_tuned       coverage_max 
                 1                  1                  1                  1                  1 

$nbParameters
[1] 5

$nbFixed
[1] 0

$nbVariable
[1] 5

# 2025-04-29 00:11:58 UTC: Parameters have been read
# 2025-04-29 00:11:58 UTC: Initialization
# Elitist race
# Elitist new instances: 1
# Elitist limit: 2
# nbIterations: 4
# minNbSurvival: 4
# nbParameters: 5
# seed: 42
# confidence level: 0.95
# budget: 180
# mu: 5
# deterministic: FALSE

# 2025-04-29 00:11:58 UTC: Iteration 1 of 4
# experimentsUsedSoFar: 0
# remainingBudget: 180
# currentBudget: 45
# nbConfigurations: 7
# 2025-04-29 00:11:58 UTC: Sample 7 configurations from uniform distribution
# 2025-04-29 00:11:58 UTC: Configurations for the race n 1 (elite configurations listed first, then new configurations):
  .ID. deck_width_tuned deck_length_tuned n_containers_delta n_classes_tuned coverage_max .PARENT.
1    1               58                83                  3               8           66       NA
2    2               15                 9                 10               8           76       NA
3    3               82                18                 19               3           23       NA
4    4               72                33                 16               4           71       NA
5    5               78                19                  1               2           71       NA
6    6               94                56                 13               2           58       NA
7    7               18                46                  7               2           26       NA
# 2025-04-29 00:11:58 UTC: Launch race
# Markers:
     x No test is performed.
     c Configurations are discarded only due to capping.
     - The test is performed and some configurations are discarded.
     = The test is performed but no configuration is discarded.
     ! The test is performed and configurations could be discarded but elite configurations are preserved.
     . All alive configurations are elite and nothing is discarded

+-+-----------+-----------+-----------+---------------+-----------+--------+-----+----+------+
| |   Instance|      Alive|       Best|      Mean best| Exp so far|  W time|  rho|KenW|  Qvar|
+-+-----------+-----------+-----------+---------------+-----------+--------+-----+----+------+
# 2025-04-29 00:11:58 UTC: /AutoIG/scripts/target-runner 1 1 1965286212 dummy   -deck_width_tuned 58 -deck_length_tuned 83 -n_containers_delta 3 -n_classes_tuned 8 -coverage_max 66
# 2025-04-29 00:12:00 UTC: DONE (1) Elapsed wall-clock seconds: 1.41
python3 -u /AutoIG/scripts/wrapper.py 1 1 1965286212 dummy -deck_width_tuned 58 -deck_length_tuned 83 -n_containers_delta 3 -n_classes_tuned 8 -coverage_max 66 > detailed-output/out-1-1965286212 2>&1
Error! NameError: name 'setting' is not defined
/AutoIG/experiments/vessel_loading_discrim/detailed-output /AutoIG/experiments/vessel_loading_discrim
/AutoIG/experiments/vessel_loading_discrim
#------------------------------------------------------------------------------
# irace: An implementation in R of (Elitist) Iterated Racing
# Version: 3.4.1.9fcaeaf
# Copyright (C) 2010-2020
# Manuel Lopez-Ibanez     <manuel.lopez-ibanez@manchester.ac.uk>
# Jeremie Dubois-Lacoste  
# Leslie Perez Caceres    <leslie.perez.caceres@ulb.ac.be>
#
# This is free software, and you are welcome to redistribute it under certain
# conditions.  See the GNU General Public License for details. There is NO
# WARRANTY; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
#
# irace builds upon previous code from the race package:
#     race: Racing methods for the selection of the best
#     Copyright (C) 2003 Mauro Birattari
#------------------------------------------------------------------------------
# installed at: /AutoIG/bin/irace
# called with: --seed 42 --scenario /AutoIG/scripts/scenario.R --parameter-file params.irace --train-instances-file instances --exec-dir ./ --max-experiments 180 --target-runner /AutoIG/scripts/target-runner --debug-level 2
## irace scenario:
scenarioFile = "./scenario.txt"
parameterFile = "/AutoIG/experiments/vessel_loading_discrim/params.irace"
execDir = "/AutoIG/experiments/vessel_loading_discrim"
logFile = "/AutoIG/experiments/vessel_loading_discrim/irace.Rdata"
recoveryFile = NULL
instances = "dummy"
initConfigurations = NULL
trainInstancesDir = ""
trainInstancesFile = "/AutoIG/experiments/vessel_loading_discrim/instances"
configurationsFile = ""
forbiddenExps = NULL = expression()
forbiddenFile = ""
targetRunner = "/AutoIG/scripts/target-runner"
targetRunnerRetries = 0
targetRunnerData = ""
targetRunnerParallel = NULL
targetEvaluator = NULL
maxExperiments = 180
maxTime = 0
budgetEstimation = 0.02
digits = 4
debugLevel = 2
nbIterations = 0
nbExperimentsPerIteration = 0
sampleInstances = TRUE
testType = "friedman"
firstTest = 5
eachTest = 1
minNbSurvival = 0
nbConfigurations = 0
mu = 5
confidence = 0.95
deterministic = FALSE
seed = 42
parallel = 0
loadBalancing = TRUE
mpi = FALSE
batchmode = "0"
softRestart = TRUE
softRestartThreshold = 1e-04
testInstancesDir = ""
testInstancesFile = ""
testInstances = NULL
testNbElites = 1
testIterationElites = FALSE
elitist = TRUE
elitistNewInstances = 1
elitistLimit = 2
repairConfiguration = function (id, allConfigurations, parameters, digits, nConfsPreviousRaces = 0) {    outputDir <- "./detailed-output/"    configuration <- allConfigurations[id - nConfsPreviousRaces,         ]    repairModel <- paste(outputDir, "/repair.eprime", sep = "")    if (!file.exists(repairModel)) {        return(configuration)    }    start_time <- Sys.time()    originalConfiguration <- configuration    baseFileName <- id    outFile <- paste(outputDir, "/repairout-", baseFileName,         sep = "")    if (file.exists(outFile)) {        configuration <- read.csv(outFile)        return(configuration)    }    lsParams <- sort(parameters$names)    for (param in lsParams) {        maxParam <- NA        if (endsWith(param, "_min")) {            maxParam <- paste(substr(param, 1, nchar(param) -                 3), "max", sep = "")        }        else if (endsWith(param, "Min")) {            maxParam <- paste(substr(param, 1, nchar(param) -                 3), "Max", sep = "")        }        if (!is.na(maxParam)) {            minVal <- min(configuration[[param]], configuration[[maxParam]])            maxVal <- max(configuration[[param]], configuration[[maxParam]])            configuration[[param]] <- minVal            configuration[[maxParam]] <- maxVal        }    }    paramFile <- paste(outputDir, "/repair-", baseFileName, ".param",         sep = "")    lsLines <- c()    for (paramName in colnames(configuration)) {        if (!(paramName %in% c(".ID.", ".PARENT."))) {            val <- configuration[[paramName]]            lsLines <- c(lsLines, paste("letting", paramName,                 "be", val))        }    }    writeLines(lsLines, con <- file(paramFile))    close(con)    seed <- as.integer(id)    cmd <- paste("conjure solve repair.essence ", paramFile,         " -o ", outputDir, " --use-existing-model repair.eprime ",         " --solver-options \"-timelimit 120 -varorder domoverwdeg -randomiseorder",         "-randomseed", seed, "\"", " --copy-solutions=off")    cat(cmd, "\n")    exitCode <- system(cmd, intern = FALSE, wait = TRUE)    if (exitCode != 0) {        cat("ERROR while repairing configuration \n")        print(configuration)        return(NULL)    }    solutionFile <- paste(outputDir, "/repair-repair-", baseFileName,         "-solution000001.solution", sep = "")    lsLines <- readLines(con <- file(solutionFile))    close(con)    lsLines <- gsub("repaired_", "", lsLines)    lsLines <- lsLines[grep("letting ", lsLines)]    baseTempName <- paste(outputDir, "/repair-repair-", baseFileName,         sep = "")    for (endName in c(".eprime-info", ".eprime-infor", ".eprime-minion",         ".eprime-param", "-solution000001.eprime-solution", "-solution000001.solution")) {        file.remove(paste(baseTempName, endName, sep = ""))    }    file.remove(paramFile)    for (paramName in colnames(configuration)) {        if (!(paramName %in% c(".ID.", ".PARENT."))) {            pattern <- paste("letting ", paramName, " be ", sep = "")            s <- lsLines[grep(pattern, lsLines)]            newVal <- as.integer(trimws(strsplit(s, " be ")[[1]][2]))            configuration[[paramName]] <- newVal        }    }    cat("\nBefore repair: \n")    print(originalConfiguration)    cat("After repair: \n")    print(configuration)    cat("\n")    end_time <- Sys.time()    cat("\nRepairing time: ", round(end_time - start_time, 2),         " seconds\n")    write.csv(configuration, file = outFile, row.names = FALSE)    return(configuration)}
capping = FALSE
cappingType = "median"
boundType = "candidate"
boundMax = NULL
boundDigits = 0
boundPar = 1
boundAsTimeout = TRUE
postselection = 0
aclib = FALSE
## end of irace scenario
# --- Parameters Hierarchy ---
[1] "deck_width_tuned"   "deck_length_tuned"  "n_containers_delta" "n_classes_tuned"    "coverage_max"      
  deck_width_tuned  deck_length_tuned n_containers_delta    n_classes_tuned       coverage_max 
                 1                  1                  1                  1                  1 
  deck_width_tuned  deck_length_tuned n_containers_delta    n_classes_tuned       coverage_max 
                ""                 ""                 ""                 ""                 "" 
           Parameter Level Depends.on
1   deck_width_tuned     1           
2  deck_length_tuned     1           
3 n_containers_delta     1           
4    n_classes_tuned     1           
5       coverage_max     1           

# ------------------------
$names
[1] "deck_width_tuned"   "deck_length_tuned"  "n_containers_delta" "n_classes_tuned"    "coverage_max"      

$types
  deck_width_tuned  deck_length_tuned n_containers_delta    n_classes_tuned       coverage_max 
               "i"                "i"                "i"                "i"                "i" 

$switches
      deck_width_tuned      deck_length_tuned     n_containers_delta        n_classes_tuned           coverage_max 
  "-deck_width_tuned "  "-deck_length_tuned " "-n_containers_delta "    "-n_classes_tuned "       "-coverage_max " 

$domain
$domain$deck_width_tuned
[1]   1 100

$domain$deck_length_tuned
[1]   1 100

$domain$n_containers_delta
[1]  1 20

$domain$n_classes_tuned
[1]  1 10

$domain$coverage_max
[1]  10 100


$conditions
$conditions$deck_width_tuned
[1] TRUE

$conditions$deck_length_tuned
[1] TRUE

$conditions$n_containers_delta
[1] TRUE

$conditions$n_classes_tuned
[1] TRUE

$conditions$coverage_max
[1] TRUE


$isFixed
  deck_width_tuned  deck_length_tuned n_containers_delta    n_classes_tuned       coverage_max 
             FALSE              FALSE              FALSE              FALSE              FALSE 

$transform
$transform$deck_width_tuned
[1] ""

$transform$deck_length_tuned
[1] ""

$transform$n_containers_delta
[1] ""

$transform$n_classes_tuned
[1] ""

$transform$coverage_max
[1] ""


$depends
$depends$deck_width_tuned
character(0)

$depends$deck_length_tuned
character(0)

$depends$n_containers_delta
character(0)

$depends$n_classes_tuned
character(0)

$depends$coverage_max
character(0)


$hierarchy
  deck_width_tuned  deck_length_tuned n_containers_delta    n_classes_tuned       coverage_max 
                 1                  1                  1                  1                  1 

$nbParameters
[1] 5

$nbFixed
[1] 0

$nbVariable
[1] 5

# 2025-04-29 00:15:53 UTC: Parameters have been read
# 2025-04-29 00:15:53 UTC: Initialization
# Elitist race
# Elitist new instances: 1
# Elitist limit: 2
# nbIterations: 4
# minNbSurvival: 4
# nbParameters: 5
# seed: 42
# confidence level: 0.95
# budget: 180
# mu: 5
# deterministic: FALSE

# 2025-04-29 00:15:53 UTC: Iteration 1 of 4
# experimentsUsedSoFar: 0
# remainingBudget: 180
# currentBudget: 45
# nbConfigurations: 7
# 2025-04-29 00:15:53 UTC: Sample 7 configurations from uniform distribution
# 2025-04-29 00:15:53 UTC: Configurations for the race n 1 (elite configurations listed first, then new configurations):
  .ID. deck_width_tuned deck_length_tuned n_containers_delta n_classes_tuned coverage_max .PARENT.
1    1               58                83                  3               8           66       NA
2    2               15                 9                 10               8           76       NA
3    3               82                18                 19               3           23       NA
4    4               72                33                 16               4           71       NA
5    5               78                19                  1               2           71       NA
6    6               94                56                 13               2           58       NA
7    7               18                46                  7               2           26       NA
# 2025-04-29 00:15:53 UTC: Launch race
# Markers:
     x No test is performed.
     c Configurations are discarded only due to capping.
     - The test is performed and some configurations are discarded.
     = The test is performed but no configuration is discarded.
     ! The test is performed and configurations could be discarded but elite configurations are preserved.
     . All alive configurations are elite and nothing is discarded

+-+-----------+-----------+-----------+---------------+-----------+--------+-----+----+------+
| |   Instance|      Alive|       Best|      Mean best| Exp so far|  W time|  rho|KenW|  Qvar|
+-+-----------+-----------+-----------+---------------+-----------+--------+-----+----+------+
# 2025-04-29 00:15:53 UTC: /AutoIG/scripts/target-runner 1 1 1965286212 dummy   -deck_width_tuned 58 -deck_length_tuned 83 -n_containers_delta 3 -n_classes_tuned 8 -coverage_max 66
# 2025-04-29 00:15:55 UTC: DONE (1) Elapsed wall-clock seconds: 1.38
python3 -u /AutoIG/scripts/wrapper.py 1 1 1965286212 dummy -deck_width_tuned 58 -deck_length_tuned 83 -n_containers_delta 3 -n_classes_tuned 8 -coverage_max 66 > detailed-output/out-1-1965286212 2>&1
Error! NameError: name 'setting' is not defined
/AutoIG/experiments/vessel_loading_discrim/detailed-output /AutoIG/experiments/vessel_loading_discrim
/AutoIG/experiments/vessel_loading_discrim
